// Code generated by go-validate. DO NOT EDIT.

package models

import (
	"errors"
	"fmt"
	"regexp"
	"strings"
)

type ValidationError struct {
	Field string
	Err   error
}

func (obj User) Validate() ([]ValidationError, error) {
	var err error
	var errors []ValidationError

	err = validateLen(obj.ID, "36")
	if err != nil {
		errors = append(errors, ValidationError{"ID", err})
	}
	err = validateMin(obj.Age, "18")
	if err != nil {
		errors = append(errors, ValidationError{"Age", err})
	}
	err = validateMax(obj.Age, "50")
	if err != nil {
		errors = append(errors, ValidationError{"Age", err})
	}
	err = validateRegexp(obj.Email, "^\\w+@\\w+\\.\\w+$")
	if err != nil {
		errors = append(errors, ValidationError{"Email", err})
	}
	err = validateIn(obj.Role, "admin,stuff")
	if err != nil {
		errors = append(errors, ValidationError{"Role", err})
	}
	for _, val := range obj.Phones {
		err = validateLen(val, "11")
		if err != nil {
			errors = append(errors, ValidationError{"Phones", err})
		}
	}

	return errors, nil
}

func (obj App) Validate() ([]ValidationError, error) {
	var err error
	var errors []ValidationError

	err = validateLen(obj.Version, "5")
	if err != nil {
		errors = append(errors, ValidationError{"Version", err})
	}
	return errors, nil
}

func (obj Response) Validate() ([]ValidationError, error) {
	var err error
	var errors []ValidationError

	err = validateIn(obj.Code, "200,404,500")
	if err != nil {
		errors = append(errors, ValidationError{"Code", err})
	}
	return errors, nil
}

func validateLen(value string, validLen string) error {
	if fmt.Sprintf("%d", len(value)) != validLen {
		return errors.New("value length is not equal to " + validLen)
	}
	return nil
}

func validateMin(value int, minValue string) error {
	if fmt.Sprintf("%d", value) < minValue {
		return errors.New("value must be higher than " + minValue)
	}
	return nil
}

func validateMax(value int, maxValue string) error {
	if fmt.Sprintf("%d", value) > maxValue {
		return errors.New("value must be lower than " + maxValue)
	}
	return nil
}

func validateRegexp(value string, regex string) error {
	if re := regexp.MustCompile(regex); !re.MatchString(value) {
		return errors.New("value doesn't match regexp")
	}
	return nil
}

func validateIn(value interface{}, validValues string) error {
	validValuesArray := strings.Split(validValues, ",")
	for _, str := range validValuesArray {
		if fmt.Sprintf("%v", value) == str {
			return nil
		}
	}
	return errors.New("value is not permitted")
}
